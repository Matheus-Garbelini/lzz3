// lzz_section
//
// a section in a generated file
//

namespace lzz
{
   // section numbers
   enum
   {
      // header
      SECTION_HEADER,
      // user section, for user include blocks
      SECTION_USER,
      // top, code that must be before declarations and body but after user code
      SECTION_TOP,
      // declarations
      SECTION_DECLARATION,
      // body, definitions
      SECTION_BODY,
      // inline sections for inlining inline file in header and source
      // inline header section
      SECTION_INLINE_HEADER,
      // inline user section
      SECTION_INLINE_USER,
      // inline section
      SECTION_INLINE_TOP,
      // inline section
      SECTION_INLINE_BODY,
      // inline tail section
      SECTION_INLINE_TAIL,
      // tail
      SECTION_TAIL,
      // max number of sections
      MAX_SECTIONS,
   };

   class Section
   {
   public:
      Section()
         : m_indent(0)
      {
         m_os = new std::ostringstream();
      }
      ~Section()
      {
         delete m_os;
      }

      // return output stream, do not first indent
      std::ostream &getStream()
      {
         assert(m_os != 0);
         return *m_os;
      }

      // indent, increment line and return output stream with optional indent offset
      std::ostream &indent(int offset = 0)
      {
         return indentExactly((m_indent + offset) * 3);
      }

      // indent exactly number of spaces
      std::ostream &indentExactly(int num_spaces)
      {
         enum { MAX_INDENT = 128 };
         char buf[MAX_INDENT];
         if (num > MAX_INDENT - 1)
         {
            num = MAX_INDENT - 1;
         }
         memset(buf, ' ', num_spaces);
         buf[num_spaces] = '\0';
         return getStream() << buf;
      }

      // increment indent
      inline void incIndent()
      {
         ++m_indent;
      }

      // decrement indent
      void decIndent()
      {
         assert(m_indent > 0);
         -- m_indent;
      }

      // close section and return contents as string
      std::string close()
      {
         std::string content = getStream().str();
         delete m_os;
         m_os = 0;
         return content;
      }

   private:
      // string buffer
      std::ostringstream *m_os;
      // current indentation
      int m_indent;
   }
}

#hdr
#include <sstream>
#end

#src
#include <cassert>
#include <cstring>
#end
