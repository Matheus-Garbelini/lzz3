namespace config
{
  // parse options, return true if no errors
  void parseOptions (int argc, char ** argv, StringVector & files)
  {
    // parse LZZ_OPTIONS and cmd line
    parseEnvOptions ();
    parseCmdLine (argc, argv, files);
    // do this at a higher level
    /*
    // must have files if not asking for help
    if (files.empty () &&
        ! (opt_help.getValue () || opt_version.getValue () || opt_rec_help.getValue () ||
           opt_print_options.getValue () || opt_print_rec_tokens.getValue ()))
    {
      ThrowException () << NoFiles ();
    }
    // option validation checks
    // if dll-api is set then dll-exports must be set too
    if (! getOptionValue (opt_dll_api).empty () && getOptionValue (opt_dll_exports).empty ())
    {
      ThrowException () << DllExportsNotSet ();
    }
    */
  }

  // print option values to os
  void printOptionValues (std::ostream & os)
  {
    os << "Option values:" << '\n';
    OptionRec const * beg = option_rec_set;
    OptionRec const * end = option_rec_set + num_options;
    for (; beg != end; ++ beg)
    {
      if (! (beg->flags & NO_VALUE_OPTION))
      {
        os << " -";
        os.setf (std::ios::left, std::ios::adjustfield);
        os.width (8);
        os << beg->name;
        Option const * option = beg->option;
        if (option->getKind () == OPTION_STRINGS)
        {
          bool first = true;
          StringVector const & str_set = static_cast <StringsOption const &> (* option).getValue ();
          for (StringVectorConstIter set_beg = str_set.begin (), set_end = str_set.end (); set_beg != set_end; ++ set_beg)
          {
            if (first)
            {
              first = false;
            }
            else
            {
              os << "          ";
            }
            os << * set_beg << '\n';
          }
          if (first)
          {
            os << '\n';
          }
        }
        else
        {
          os << option->getValueAsString () << '\n';
        }
      }
    }
  }
}

using namespace std;
using namespace config;

namespace
{
  // option flags
  enum
  {
    // do not display option in -v
    NO_VALUE_OPTION = 1 << 0,
  };

  // option record
  struct OptionRec
  {
    // name
    char const * name;
    // old name (for backward compatibility)
    char const * old_name;
    // option
    Option * option;
    // flags
    int flags;
  }

  // option records
  OptionRec option_rec_set [] =
  {
    // bootstrap basil parser with lua rules filename 
    { "s",  0, & opt_lzz_dir, 0 },
    { "bb", 0, & opt_bootstrap_basil, 0 },
    { "cb", 0, & opt_compile_basil, 0 },
    { "cl", 0, & opt_compile_lzz, 0 },

    { "i", "inl", & opt_inl, 0 },
    { "t", "tpl", & opt_tpl, 0 },
    { "n", "tnl", & opt_tnl, 0 },

    { "hx", "hdr-ext", & opt_hdr_ext, 0 },
    { "sx", "src-ext", & opt_src_ext, 0 },
    { "ix", "inl-ext", & opt_inl_ext, 0 },
    { "tx", "tpl-ext", & opt_tpl_ext, 0 },
    { "nx", "tnl-ext", & opt_tnl_ext, 0 },
    
    { "hl", "hdr-line", & opt_hdr_line, 0 },
    { "sl", "src-line", & opt_src_line, 0 },
    { "il", "inl-line", & opt_inl_line, 0 },
    { "tl", "tpl-line", & opt_tpl_line, 0 },
    { "nl", "tnl-line", & opt_tnl_line, 0 },

    { "hd", "hdr-smart-write", & opt_hdr_smart_write, 0 },
    { "sd", "src-smart-write", & opt_src_smart_write, 0 },
    { "id", "inl-smart-write", & opt_inl_smart_write, 0 },
    { "td", "tpl-smart-write", & opt_tpl_smart_write, 0 },
    { "nd", "tnl-smart-write", & opt_tnl_smart_write, 0 },

    { "c", "src-if-hdr", & opt_src_if_hdr, 0 },
    { "o", "out-dir", & opt_out_dir, 0 },
    { "da", "dll-api", & opt_dll_api, 0 },
    { "dx", "dll-exports", & opt_dll_exports, 0 },
    { "x", 0, & opt_expand_filename, 0 },
    { "d", "delete-old", & opt_delete_old, 0 },
    { "I", 0, & opt_incl_path_set, 0 },
    { "D", 0, & opt_macro_set, 0 },
    { "a", 0, & opt_auto_includes, 0 },
    { "p", 0, & opt_pp, 0 },
    { "P", 0, & opt_pp_all, 0 },
    { "E", 0, & opt_pp_incl, 0 },
    { "r", 0, & opt_rec, 0 },

    { "e",  0, & opt_prep_block, 0 },
    { "b",  0, & opt_tab_stop, 0 },

    { "k", 0, & opt_package, 0 },
    { "tr", 0, & opt_trace, 0 },

    { "v", 0, & opt_print_options, NO_VALUE_OPTION },
    { "hr", 0, & opt_rec_help, NO_VALUE_OPTION },
    { "T", 0, & opt_print_rec_tokens, NO_VALUE_OPTION },
    { "ver", 0,  & opt_version, NO_VALUE_OPTION },
    { "h", 0, & opt_help, NO_VALUE_OPTION },
    { "help", 0, & opt_help, NO_VALUE_OPTION },

    // working options
    { "g", 0, & opt_gen_parser, 0 },
  };

  // number of options
  const int num_options = sizeof (option_rec_set) / sizeof (option_rec_set [0]);

  // get option, return 0 if not found
  Option * getOption (char const * name, int & flags)
  {
    Option * option = 0;
    OptionRec const * beg = option_rec_set;
    OptionRec const * end = option_rec_set + num_options;
    for (; beg != end; ++ beg)
    {
      if ((beg->name != 0 && strcmp (beg->name, name) == 0) || (beg->old_name != 0 && strcmp (beg->old_name, name) == 0))
      {
        option = beg->option;
        flags = beg->flags;
        break;
      }
    }
    return option;
  }

  // parse env options in LZZ_OPTIONS string
  void parseEnvOptions (string const & str)
  {
    StringConstIter str_beg = str.begin ();
    StringConstIter str_end = str.end ();
    char const * ws = " \t";
    for (;;)
    {
      string word = getNextWord (skipWs (str_beg, str_end, ws), str_end, ws, str_beg);
      if (word.empty ())
      {
        break;
      }
      char const * opt = word.c_str ();
      // discard leading dash if present
      if (opt [0] == '-')
      {
        ++ opt;
        if (opt [0] == '\0' || opt [0] == ' ')
        {
          ThrowException () << "option expected after dash";
        }
      }
      // check if single letter option
      if (isupper (opt [0]) && opt [1] != '\0')
      {
        // search for option
        char opt1 [2];
        opt1 [0] = opt [0];
        opt1 [1] = '\0';
        int flags;
        Option * option = getOption (opt1, flags);
        if (! option)
        {
          ThrowException () << "invalid option: " << opt1;
        }
        option->setValue (opt + 1);
      }
      else
      {
        // check if preceded with 'no-'
        bool has_no = false;
        if (memcmp (opt, "no-", 3) == 0)
        {
          has_no = true;
          opt += 3;
        }
        // get option
        int flags;
        Option * option = getOption (opt, flags);
        if (! option)
        {
          ThrowException () << "invalid option: " << opt;
        }
        if (option->isBoolOption ())
        {
          // has_no is the value
          option->setValue (has_no ? "no" : "yes");
        }
        else if (has_no)
        {
          ThrowException () << "option cannot take a 'no' prefix: " << opt;
        }
        else
        {
          string value = getNextWord (skipWs (str_beg, str_end, ws), str_end, ws, str_beg);
          if (value.empty ())
          {
            ThrowException () << "value expected after option " << opt;
          }
          option->setValue (value);
        }
      }
    }
  }

  // parse options in LZZ_OPTIONS, return true if no errors
  void parseEnvOptions ()
  {
    // do nothing if environment variable is not set
    string env_options;
    if (getEnv ("LZZ_OPTIONS", env_options))
    {
      parseEnvOptions (env_options);
    }
  }

  // parse command line options, return true if no errors
  void parseCmdLine (int argc, char ** argv, StringVector & files)
  {
    for (int i = 1; i < argc; i ++)
    {
      char * opt = argv [i];
      if (* opt != '-')
      {
        // must be file name
        files.push_back (argv [i]);
      }
      else
      {
        ++ opt;
        // check if has opt
        if (* opt == '\0')
        {
          ThrowException () << "option expected after '-'";
        }
        // check if single letter option, eg: -D or -I
        if (isupper (opt [0]) && opt [1] != '\0')
        {
          // search for option
          char opt1 [2];
          opt1 [0] = opt [0];
          opt1 [1] = '\0';
          int flags;
          Option * option = getOption (opt1, flags);
          if (! option)
          {
            ThrowException () << opt1 << " is not a valid option";
          }
          option->setValue (opt + 1);
        }
        else
        {
          // check if preceeded with "no-"
          bool has_no = false;
          if (memcmp (opt, "no-", 3) == 0)
          {
            has_no = true;
            opt += 3;
          }
          // search for option
          int flags;
          Option * option = getOption (opt, flags);
          if (! option)
          {
            ThrowException () << opt << " is not a valid option";
          }
          // bool option has no value
          if (option->isBoolOption ())
          {
            // has_no is the value
            option->setValue (has_no ? "no" : "yes");
          }
          // get value
          else
          {
            if (has_no)
            {
              ThrowException () << opt << " is not a yes/no option";
            }
            if (i + 1 == argc)
            {
              ThrowException () << "valid expected after option " << opt;
            }
            char const * value = argv [++ i];
            option->setValue (value);
          }
        }
      }
    }
  }
}

#hdr
#include <util/string_vector.h>
#end

#src
#include <config/option.h>
#include <config/options.h>
#include <util/get_env.h>
#include <util/get_next_word.h>
#include <util/skip_ws.h>
#include <util/file_op.h>
#include <util/throw_exception.h>
#include <algorithm>
#include <cctype>
#include <cstring>
#include <iostream>
#end
