// lzz_output_lua.lzz
//

namespace lzz
{
   class Output;

   // expose lzz api
   class OutputLua
   {
   public:
      OutputLua(lua_State *L, Output &output)
         : L(L)
      {
         lua_newtable(L);
         lua_pushlightuserdata(L, &output);
         luaL_setfuncs(L, output_fns, 1);
         lua_pushinteger(L, SECTION_BODY);
         lua_setfield(L, -2, "BODY");
         lua_pushinteger(L, SECTION_DECLARATION);
         lua_setfield(L, -2, "DECL");
         lua_setglobal(L, "lzz");
      }
      ~OutputLua()
      {
         lua_pushnil(L);
         lua_setglobal(L, "lzz");
      }

   private:
      lua_State *L;
   };

   // create metatables
   void register_types(lua_State *L)
   {
      luaL_newmetatable(L, MT_FILE_SECTION);
      luaL_setfuncs(L, file_section_fns, 0);
      lua_setfield(L, -1, "__index"); // mt.__index=mt and pop mt
   }
}

using namespace lzz;

namespace
{
   // warning
   int lzz_warning(lua_State *L)
   {
      Output &output = *static_cast<Output *>(lua_touserdata(L, lua_upvalueindex(1)));
      Loc const &loc = get_loc(L, 1);
      char const *msg = luaL_checkstring (L, 2);
      output.warning(loc, msg);
      return 0;
   }

   // error
   int lzz_error (lua_State * L)
   {
      Output &output = *static_cast<Output *>(lua_touserdata(L, lua_upvalueindex(1)));
      Loc const &loc = get_loc(L, 1);
      char const *msg = luaL_checkstring(L, 2);
      output.error(loc, msg);
      return 0;
   }

   // File and section number pair
   char const MT_FILE_SECTION [] = "lzz.FileSection";
   struct FileSection(File &file, int section_num) {}

   // hdr file
   int lzz_hdr_helper(lua_State *L, int section_num)
   {
      Output &output = *static_cast<Output *>(lua_touserdata(L, lua_upvalueindex(1)));
      bool inl = lua_toboolean(L, 1) != 0;
      bool tpl = lua_toboolean(L, 2) != 0;
      File &file = output.get_hdr(inl, tpl);
      new(lua_newuserdata(L, sizeof(FileSection))) FileSection(file, section_num);
      luaL_setmetatable(L, MT_FILE_SECTION);
      return 1;
   }
   // hdr file
   int lzz_hdr(lua_State *L)
   {
      return lzz_hdr_helper(L, luaL_optinteger(L, 3, SECTION_BODY));
   }
   // hdr declaration
   int lzz_hdr_decl(lua_State *L)
   {
      return lzz_hdr_helper(L, SECTION_DECLARATION);
   }
   // hdr body
   int lzz_hdr_body(lua_State *L)
   {
      return lzz_hdr_helper(L, SECTION_BODY);
   }

   // src file
   int lzz_src_helper(lua_State *L, int section_num)
   {
      Output &output = *static_cast<Output *>(lua_touserdata(L, lua_upvalueindex(1)));
      File &file = output.get_src();
      new(lua_newuserdata(L, sizeof(FileSection))) FileSection(file, section_num);
      luaL_setmetatable(L, MT_FILE_SECTION);
      return 1;
   }
   // src declaration
   int lzz_src(lua_State *L)
   {
      return lzz_src_helper(L, luaL_optinteger(L, 1, SECTION_BODY));
   }
   // src declaration
   int lzz_src_decl(lua_State *L)
   {
      return lzz_src_helper(L, SECTION_DECLARATION);
   }
   // src file
   int lzz_src_body(lua_State *L)
   {
      return lzz_src_helper(L, SECTION_BODY);
   }

   // print open brace and indent
   int lzz_print_open_brace(lua_State *L)
   {
      FileSection const &fs = *static_cast<FileSection const *>(luaL_checkudata(L, 1, MT_FILE_SECTION));
      print_open_brace(fs.file, fs.section_num);
      return 0;
   }

   // print close brace and unindent
   int lzz_print_close_brace(lua_State *L)
   {
      FileSection const &fs = *static_cast<FileSection const *>(luaL_checkudata(L, 1, MT_FILE_SECTION));
      bool semi = lua_toboolean(L, 2) != 0;
      print_close_brace(fs.file, fs.section_num, semi);
      return 0; 
   }

   // print line
   int lzz_print(lua_State *L)
   {
      FileSection const &fs = *static_cast<FileSection const *>(luaL_checkudata(L, 1, MT_FILE_SECTION));
      Loc const &loc = get_loc(L, 2);
      char const *line = luaL_checkstring(L, 3);
      int offset = luaL_optinteger(L, 4, 0); 
      print_line(fs.file, fs.section_num, loc, line, offset);
      return 0;
   }

   // print brace enclosed block
   int lzz_print_enclosed_block(lua_State *L)
   {
      FileSection const &fs = *static_cast<FileSection const *>(luaL_checkudata(L, 1, MT_FILE_SECTION));
      File &file = fs.file;
      int section_num = fs.section_num;
      Loc const &loc = get_loc(L, 2);
      char const *code = luaL_checkstring(L, 3);
      file.indent(section_num) << '{' << '\n';
      print_hash_line(file, section_num, loc);
      if (code[0] != '\0')
      {
         file.indent_exactly(section_num, loc.get_column() - 1) << code << '\n';
      }
      file.indent(section_num) << '}' << '\n';
      return 0;
   }

   luaL_Reg const output_fns[] =
   {
      { "warning", lzz_warning },
      { "error", lzz_error },
      { "hdr", lzz_hdr },
      { "src", lzz_src },
      { "hdr_decl", lzz_hdr_decl },
      { "hdr_body", lzz_hdr_body },
      { "src_decl", lzz_src_decl },
      { "src_body", lzz_src_body },
      { 0, 0 },
   };

   luaL_Reg const file_section_fns[] =
   {
      { "print_open_brace", lzz_print_open_brace },
      { "print_close_brace",  lzz_print_close_brace },
      { "print_enclosed_block", lzz_print_enclosed_block },
      { "print", lzz_print },
      { 0, 0 },
   };

   // get loc at arg i
   basil::Loc get_loc(lua_State *L, int i)
   {
      return *static_cast<basil::Loc*>(luaL_checkudata(L, i, basil::MT_LOC));
   }
}

#hdr
#include <lua.h>
#end

#src
#include <lzz_output.h>
#include <basil_engine.h>
#include <lualib.h>
#include <lauxlib.h>
#include <cstring>
#end
