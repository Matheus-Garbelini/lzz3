// lzz_output
//

namespace lzz
{
   class Output
   {
   public:
      Output(std::string const &path, std::string const &name, std::ostream &out_stream)
         : m_hdr(FILE_HDR, path, name, getOptionValue(opt_hdr_ext), getOptionValue(opt_hdr_line), getOptionValue(opt_hdr_smart_write)),
           m_src(FILE_SRC, path, name, getOptionValue(opt_src_ext), getOptionValue(opt_src_line), getOptionValue(opt_src_smart_write)),
           m_inl(FILE_INL, path, name, getOptionValue(opt_inl_ext), getOptionValue(opt_inl_line), getOptionValue(opt_inl_smart_write)),
           m_tpl(FILE_TPL, path, name, getOptionValue(opt_tpl_ext), getOptionValue(opt_tpl_line), getOptionValue(opt_tpl_smart_write)),
           m_tnl(FILE_TNL, path, name, getOptionValue(opt_tnl_ext), getOptionValue(opt_tnl_line), getOptionValue(opt_tnl_smart_write)),
           m_out_stream(out_stream), m_any_error(false)
      {}
      ~Output()
      {}

      // close all files
      void close(bool save)
      {
         // write any last code before closing any files
         if (save)
         {
            finalize_hdr();
            finalize_src();
            finalize_inl();
            finalize_tpl();
            finalize_tnl();
         }
         bool delete_old = getOptionValue(opt_delete_old);
         m_hdr.close(save, delete_old);
         m_src.close(save, delete_old);
         m_inl.close(save, delete_old);
         m_tpl.close(save, delete_old);
         m_tnl.close(save, delete_old);
      }

      // get header file
      File &get_hdr()
      {
         open_hdr();
         return m_hdr;
      }

      // get source file
      File &get_src()
      {
         open_src();
         return m_src;
      }

      // get header file with inline and template options
      inline File &get_hdr(bool inl, bool tpl)
      {
         if (tpl)
         {
            return inl ? get_tnl() : get_tpl();
         }
         else
         {
            return inl ? get_inl() : get_hdr();
         }      
      }

      // get inline file
      File &get_inl()
      {
         if (!getOptionValue(opt_inl))
         {
            return get_hdr();
         }        
         open_inl();
         return m_inl;
      }

      // get template file
      File &get_tpl()
      {
         if (!(m_use_tpl || getOptionValue(opt_tpl)))
         {
            return get_hdr();
         }        
         open_tpl();
         return m_tpl;
      }

      // get template inline file
      File &get_tnl()
      {
         if (!getOptionValue(opt_tnl))
         {
            return get_hdr();
         }        
         open_tnl();
         return m_tnl;
      }

      // use template file (flag can be set using #pragma)
      void use_tpl()
      {
         m_use_tpl = true;
      }

      // output error message
      void error(Loc const &loc, std::string const &msg)
      {
         m_any_error = true;
         m_out_stream << loc << msg << std::endl;
      }
      // output error message
      void error(std::string const &msg)
      {
         m_any_error = true;
         m_out_stream << msg << std::endl;
      }

      // output warning message, not fatal
      void warning(Loc const &loc, std::string const &msg)
      {
         m_out_stream << loc << msg << std::endl;
      }
      // output warning message, not fatal
      void warning(std::string const &msg)
      {
         m_out_stream << msg << std::endl;
      }

      // true if has any error
      bool has_error() const
      {
         return m_any_error;
      }

   private:
      //
      // open/finalize header
      //
      void open_hdr()
      {
         // open and initialize
         if (m_hdr.open())
         {            
            // info
            print_info(m_hdr);

            // include guard
            std::string guard_id = get_include_guard_id(m_hdr.get_name());
            m_hdr.header() << "#ifndef " << guard_id << '\n';
            m_hdr.header() << "#define " << guard_id << '\n';

            // define inline macro for header inlines 
            m_hdr.top() << "#define LZZ_INLINE inline" << '\n';

            if (getOptionValue(opt_src_if_hdr))
            {
               open_src();
            }
         }
      }

      void finalize_hdr()
      {
         // finalize if open
         if (m_hdr.is_open())
         {
            // undef LZZ_INLINE before rest
            m_hdr.body() << "#undef LZZ_INLINE" << '\n';

            // inline file
            if (m_hdr.has_section(SECTION_INLINE_USER) || m_hdr.has_section(SECTION_INLINE_BODY))
            {
               assert(!m_inl.is_open());
               m_hdr.inline_header() << "#ifdef LZZ_ENABLE_INLINE" << '\n';
               m_hdr.inline_top()    << "#define LZZ_INLINE inline" << '\n';
               m_hdr.inline_body()   << "#undef LZZ_INLINE" << '\n';
               m_hdr.inline_tail()   << "#endif" << '\n';
            }
            else if (m_inl.is_open())
            {
               m_hdr.tail() << "#ifdef LZZ_ENABLE_INLINE" << '\n';
               m_hdr.tail() << "#include \"" << m_inl.get_name() << '\"' << '\n';
               m_hdr.tail() << "#endif" << '\n';
            }

            // include inline template file if created
            if (m_tnl.is_open())
            {
               if (m_tpl.is_open())
               {
                  m_hdr.tail() << "#ifdef LZZ_ENABLE_INLINE" << '\n';
               }
               m_hdr.tail() << "#include \"" << m_tnl.get_name() << '\"' << '\n';
               if (m_tpl.is_open())
               {
                  m_hdr.tail() << "#endif" << '\n';
               }
            }
            // close include guard
            m_hdr.tail() << "#endif" << '\n';
         }
      }

      //
      // open/finalize source file
      //
      void open_src()
      {
         if (m_src.open())
         {
            // info
            print_info(m_src);

            // include header file as first line
            open_hdr();
            m_src.header() << "#include \"" << m_hdr.get_name() << '\"' << '\n';

            // define inline macro for static and unnamed namespace inlines 
            m_src.top() << "#define LZZ_INLINE inline" << '\n';
         }
      }

      void finalize_src()
      {
         if (m_src.is_open())
         {
            // inline file
            if (m_hdr.has_section(SECTION_INLINE_USER) || m_hdr.has_section(SECTION_INLINE_BODY))
            {
               assert(!m_inl.is_open());
               m_src.inline_header() << "#ifndef LZZ_ENABLE_INLINE" << '\n';
               m_src.inline_top()    << "#define LZZ_INLINE" << '\n';
               m_src.inline_body()   << "#undef LZZ_INLINE" << '\n';
               m_src.inline_tail()   << "#endif" << '\n';
            }
            else if (m_inl.is_open())
            {
               m_src.header() << "#ifndef LZZ_ENABLE_INLINE" << '\n';
               m_src.header() << "#include \"" << m_inl.get_name() << '\"' << '\n';
               m_src.header() << "#endif" << '\n';
            }

            // remove inline macro
            m_src.body() << "#undef LZZ_INLINE" << '\n';
         }
      }

      //
      // open/finalize inline file
      //
      void open_inl()
      {
         if (m_inl.open())
         {
            print_info(m_inl);

            // must have header and source
            open_hdr();
            open_src();

            // inline macro
            m_inl.top() << "#ifdef LZZ_ENABLE_INLINE" << '\n';
            m_inl.top() << "#define LZZ_INLINE inline" << '\n';
            m_inl.top() << "#else" << '\n';
            m_inl.top() << "#define LZZ_INLINE" << '\n';
            m_inl.top() << "#endif" << '\n';
         }
      }

      void finalize_inl()
      {
         if (m_inl.is_open())
         {
            // remove inline macro
            m_inl.body() << "#undef LZZ_INLINE" << '\n';
         }
      }

      //
      // open/finalize template file
      //
      void open_tpl()
      {
         if (m_tpl.open())
         {
            // info
            print_info(m_tpl);
            // include header file
            open_hdr();
            m_tpl.header() << "#include \"" << m_hdr.get_name() << '\"' << '\n';
         }
      }
    
      void finalize_tpl()
      {
         if (m_tpl.is_open())
         {
            // include template inline file if exists
            if (m_tnl.is_open())
            {
               // write to header part of file
               m_tpl.header() << "#ifndef LZZ_ENABLE_INLINE" << '\n';
               m_tpl.header() << "#include \"" << m_tnl.get_name() << '\"' << '\n';
               m_tpl.header() << "#endif" << '\n';
            }
         }
      }

      //
      // open/finalize template inline file
      //
      void open_tnl()
      {
         if (m_tnl.open())
         {
            // info
            print_info(m_tnl);

            // set inline macro after all include blocks
            m_tnl.top() << "#ifdef LZZ_ENABLE_INLINE" << '\n';
            m_tnl.top() << "#define LZZ_INLINE inline" << '\n'; 
            m_tnl.top() << "#else" << '\n'; 
            m_tnl.top() << "#define LZZ_INLINE" << '\n'; 
            m_tnl.top() << "#endif" << '\n';

            // requires header and template files
            open_hdr();

            // if writing to tnl file and using tpl file, make sure tpl file is open
            if (getOptionValue(opt_tpl))
            {
               open_tpl();
            }
         }
      }

      void finalize_tnl()
      {
         if (m_tnl.is_open())
         {
            // remove inline macro
            m_tnl.body() << "#undef LZZ_INLINE" << '\n';
         }
      }

   private:
      // header file
      File m_hdr;
      // source file
      File m_src;
      // inline file
      File m_inl;
      // template file
      File m_tpl;
      // inline template file
      File m_tnl;
      // create tpl file (set using #pragma)
      bool m_use_tpl;
      // output stream for errors and warnings
      std::ostream &m_out_stream;
      // true if any errors
      bool m_any_error;
   };
}

using namespace lzz;
using namespace config;

namespace
{
   // get include guard identifier, name is filename w/o path
   std::string get_include_guard_id(std::string const &name)
   {
      std::string result = "LZZ_";
      std::string const &package = getOptionValue(opt_package);
      if (!package.empty())
      {
         result += package;
         result += '_';
      }
      result += name;
      // replace non identifier chars with underscore
      for (std::string::iterator i = result.begin(); i != result.end(); ++i)
      {
         char &ch = * i;
         if (!isalnum(ch))
         {
            ch = '_';
         }
      }
      return result;
   }

   // print file info
   void print_info(File &file)
   {
      // info goes in header part of file
      std::ostream &os = file.header();
      os << "// " << file.get_name() << '\n';
      os << "//" << '\n';
      os << '\n';
   }
}

#hdr
#include <lzz_file.h>
#include <string>
#end

#src
#include <config_options.h>
#include <util_file_op.h>
#include <util_array_size.h>
#include <cassert>
#include <cctype>
#include <cstring>
#include <iostream>
#end
