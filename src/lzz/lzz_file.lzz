// lzz_file
//
// an lzz generated file
//

namespace lzz
{
   enum FileKind
   {
      FILE_HDR, // header
      FILE_SRC, // source
      FILE_INL, // inline
      FILE_TPL, // template
      FILE_TNL, // template inline
   };

   class File
   {
   public:
      File(FileKind kind, std::string const &path, std::string const &name, std::string const &ext, bool hash_lines, bool smart_write)
         : m_kind(kind), m_name(file_op::join(name, ext)), m_fullname(file_op::join(path, m_name)), m_hash_lines(hash_lines), m_smart_write(smart_write)
      {}
      ~File()
      {}
      
      // get fullname (path/name.ext)
      std::string const &get_fullname() const
      {
         return m_fullname;
      }
      
      // get name, fullname w/o path
      std::string const &get_name() const
      {
         return m_name;
      }   

      // true if #lines in file
      bool has_hash_lines() const
      {
         return m_hash_lines;
      }

      // true if has section
      bool has_section(int section_num) const
      {
         return m_sections[section_num].get() != 0;
      }

      // get section, create one if not present
      Section &get_section(int section_num)
      {
         SectionPtr &section_ptr = m_sections[section_num];
         if (!section_ptr)
         {
            section_ptr.reset(new Section);
         }
         return *section_ptr;
      }

      // get section stream
      std::ostream &get_stream(int section_num)
      {
         return get_section(section_num).get_stream();
      }

      // indent, increment line and return output stream with optional indent offset
      std::ostream &indent(int section_num, int offset = 0)
      {
         return get_section(section_num).indent(offset);
      }

      // indent exactly number of spaces
      std::ostream &indent_exactly(int section_num, int num_spaces)
      {
         return get_section(section_num).indent_exactly(num_spaces);
      }

      // increment indent
      void inc_indent(int section_num)
      {
         get_section(section_num).inc_indent();
      }

      // decrement indent
      void dec_indent(int section_num)
      {
         get_section(section_num).dec_indent();
      }

      // get section content, close section
      std::string get_content(int section_num)
      {
         if (!has_section(section_num))
         {
            return std::string();
         }
         return get_section(section_num).close();
      }

      //
      // stream helpers
      //

      // return header output stream
      inline std::ostream &header()
      {
         return get_stream(SECTION_HEADER);
      }

      // return body output stream
      inline std::ostream &body()
      {
         return get_stream(SECTION_BODY);
      }

      // return body output stream
      inline std::ostream &top()
      {
         return get_stream(SECTION_TOP);
      }

      // return body output stream
      inline std::ostream &tail()
      {
         return get_stream(SECTION_TAIL);
      }

      // return inline header output stream
      inline std::ostream &inline_header()
      {
         return get_stream(SECTION_INLINE_HEADER);
      }

      // return inline header output stream
      inline std::ostream &inline_top()
      {
         return get_stream(SECTION_INLINE_TOP);
      }

      // return inline header output stream
      inline std::ostream &inline_body()
      {
         return get_stream(SECTION_INLINE_BODY);
      }

      // return body output stream
      inline std::ostream &inline_tail()
      {
         return get_stream(SECTION_INLINE_TAIL);
      }

      // true if file open
      inline bool is_open()
      {
         return !m_sections.empty();
      }

      // open file, return true if not already open
      bool open()
      {
         if (m_sections.empty())
         {
            m_sections.resize(MAX_SECTIONS);
            return true;
         }
         return false;
      }

      // close file, write file to disk if open and save=true, otherwise delete existing file if delete_old=true
      void close(bool save, bool delete_old)
      {
         if (save && !m_sections.empty())
         {
            FileContent content(*this);
            content.append(SECTION_HEADER);
            if (m_kind == FILE_SRC)
            {
               // inline sections
               content.append(SECTION_INLINE_HEADER);
               content.append(SECTION_INLINE_USER);
               content.append(SECTION_INLINE_TOP);
               content.append(SECTION_INLINE_BODY);
               content.append(SECTION_INLINE_TAIL);
            }
            content.append(SECTION_USER);
            content.append(SECTION_TOP);
            content.append(SECTION_DECLARATION);
            content.append(SECTION_BODY);
            if (m_kind == FILE_HDR)
            {
               // inline sections
               content.append(SECTION_INLINE_HEADER);
               content.append(SECTION_INLINE_USER);
               content.append(SECTION_INLINE_TOP);
               content.append(SECTION_INLINE_BODY);
               content.append(SECTION_INLINE_TAIL);
            }
            content.append(SECTION_TAIL);
            m_sections.clear();
            // compare with existing file if smart write on
            if (!(m_smart_write && content.same()))
            {
               content.write();
            }
         }
         else if (delete_old && file_op::exists(m_fullname))
         {
            file_op::del(m_fullname.c_str());
         }
      }

   private:
      FileKind m_kind;          
      // name (base.ext)
      std::string m_name;
      // full name (path/base.ext)
      std::string m_fullname;
      // generate #lines
      bool m_hash_lines;
      // sections, file closed if empty
      SectionPtrVector m_sections;
      // write only if conents different
      bool m_smart_write;
   };

   // print hash line to file section, get filename and line number from loc
   void print_hash_line(File &file, int section_num, Loc const &loc)
   {
      if (file.has_hash_lines())
      {
         char const *fullname = loc.get_fullname();
         file.get_stream(section_num) << "#line " << loc.get_line() << " \"" << fullname << '\"' << '\n';
      }
   }

   // indent and print line with newline
   void print_line(File &file, int section_num, std::string const &line, int offset = 0)
   {
      file.indent(section_num, offset) << line << '\n';
   }

   // indent and print line and newline at location
   void print_line(File &file, int section_num, Loc const &loc, std::string const &line, int offset = 0)
   {
      print_hash_line(file, section_num, loc);
      file.indent(section_num, offset) << line << '\n';
   }

   // print open brace and indent 
   void print_open_brace(File &file, int section_num)
   {
      file.indent(section_num) << '{' << '\n';
      file.inc_indent(section_num);
   }

   // print close brace with optional semi-colon and decrement indent level
   void print_close_brace(File &file, int section_num, bool semi)
   {
      file.dec_indent(section_num);
      std::ostream &os = file.indent(section_num) << '}';
      if (semi)
      {
         os << ';';
      }
      os << '\n';
   }

   // print (#hdr, #src, etc) block to file
   void print_block(File &file, Loc const &loc, std::string const &str)
   {
      // aways goes in user section
      print_hash_line(file, SECTION_USER, loc);
      file.get_stream(SECTION_USER) << str << '\n';
   }
}

using namespace lzz;

namespace
{
   // file conent
   struct FileContent(File &file)
   {
      // append section content
      void append(int section_num)
      {
         file.get_content(section_num).swap(*contents.insert(contents.end(), std::string()));
      }

      // true if file exists and contents equal
      bool same()
      {
         bool equal = false;
         std::string const &filename = file.get_fullname();
         if (file_op::exists(filename))
         {
            if (FILE *fp = fopen(filename.c_str(), "r"))
            {
               if (std::find_if(contents.begin(), contents.end(), std::not1(Same(fp))) == contents.end() && fgetc(fp) == EOF)
               {
                  equal = true;
               }
               fclose(fp);
            }
            else
            {
               throw std::runtime_error(Message("failed to read %") << filename);
            }
         }
         return equal;
      }

      // write contents to file
      void write()
      {
         std::string const &filename = file.get_fullname();
         if (FILE *fp = fopen(filename.c_str(), "w"))
         {
            std::for_each(contents.begin(), contents.end(), Write(fp));
            fclose(fp);
         }
         else
         {
            throw std::runtime_error(Message("failed to write %") << filename);
         }
      }
   
   private:
      typedef std::list<std::string> StringList;
      StringList contents;

      // true if string part same in file 
      bool Same(FILE *fp; std::string const &str) const : std::unary_function<std::string, bool>
      {
         for (std::string::const_iterator i = str.begin(), endi = str.end(); i != endi; ++i)
         {
            int ch = fgetc(fp);
            if (ch == EOF || *i != ch)
            {
               return false;
            }
         }
         return true;
      }
      // write string part to file
      void Write(FILE *fp; std::string const &str) const
      {
         fwrite(str.data(), sizeof(char), str.size(), fp);
      }
   };
}

#hdr
#include <lzz_section.h>
#include <lzz_section_ptr_vector.h>
#include <util_loc.h>
#include <cstdio>
#include <string>
#end

#src
#include <util_file_op.h>
#include <util_message.h>
#include <algorithm>
#include <functional>
#include <list>
#include <stdexcept>
#end
