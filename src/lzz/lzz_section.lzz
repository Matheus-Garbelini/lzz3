// lzz_section
//
// section in a generated file
//

namespace lzz
{
   // section numbers
   enum
   {
      // header
      SECTION_HEADER,
      // user section, for user include blocks
      SECTION_USER,
      // top, code that must be before declarations and body but after user code
      SECTION_TOP,
      // declarations
      SECTION_DECLARATION,
      // body, definitions
      SECTION_BODY,
      // inline sections for inlining inline file in header and source
      // inline header section
      SECTION_INLINE_HEADER,
      // inline user section
      SECTION_INLINE_USER,
      // inline section
      SECTION_INLINE_TOP,
      // inline section
      SECTION_INLINE_BODY,
      // inline tail section
      SECTION_INLINE_TAIL,
      // tail
      SECTION_TAIL,
      // max number of sections
      MAX_SECTIONS,
   };

   class Section
   {
   public:
      Section()
         : m_indent(0)
      {
         m_os = new std::ostringstream();
      }
      ~Section()
      {
         delete m_os;
      }

      // return output stream, do not first indent
      std::ostream &get_stream()
      {
         assert(m_os != 0);
         return *m_os;
      }

      // indent, increment line and return output stream with optional indent offset
      std::ostream &indent(int offset = 0)
      {
         return indent_exactly((m_indent + offset) * 3);
      }

      // indent exactly number of spaces
      std::ostream &indent_exactly(int num_spaces)
      {
         int const MAX_INDENT = 128;
         char buf[MAX_INDENT];
         num_spaces = std::min(MAX_INDENT, num_spaces);
         memset(buf, ' ', num_spaces);
         return get_stream().write(buf, num_spaces);
      }

      // increment indent
      inline void inc_indent()
      {
         ++m_indent;
      }

      // decrement indent
      void dec_indent()
      {
         assert(m_indent > 0);
         -- m_indent;
      }

      // close section and return contents as string
      std::string close()
      {
         assert(m_os != 0);
         std::string content = m_os->str();
         delete m_os;
         m_os = 0;
         return content;
      }

   private:
      // string buffer
      std::ostringstream *m_os;
      // current indentation
      int m_indent;
   }
}

#hdr
#include <sstream>
#end

#src
#include <cassert>
#include <cstring>
#end
